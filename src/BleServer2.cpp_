#include "BleServer.h"

bool deviceConnected, oldDeviceConnected;
bool mConn;
BlynkFifo<uint8_t, BLYNK_MAX_READBYTES*2> mBuffRX;
char auth[] = "l7b1ongYuGiRcnDHufxwnazMH6hAn3Xl";
boolean blink = false;
int lastBlink = 0;
Stream *vescSerial;
std::string bufferString;
NimBLECharacteristic *pTxCharacteristicUart;
NimBLECharacteristic *pTxCharacteristicBlynk;

static BleServer _blynkTransportBLE;
BlynkEsp32_BLE Blynk(_blynkTransportBLE);

BleServer::BleServer() {}

void BleServer::init(Stream *vesc) {

  if(initialized) {
    return;
  }
  
  vescSerial = vesc;

  // Create the BLE Device
  NimBLEDevice::init(BT_NAME);
  NimBLEDevice::setPower(ESP_PWR_LVL_P9);

  // Create the BLE Server
  pServer = NimBLEDevice::createServer();
  pServer->setCallbacks(this);

  // Create the BLE UART Service
  NimBLEService *pServiceUart = pServer->createService(VESC_SERVICE_UUID);

  // Create a BLE Characteristic for RX and TX
  pTxCharacteristicUart = pServiceUart->createCharacteristic(
										VESC_CHARACTERISTIC_UUID_TX,
										NIMBLE_PROPERTY::NOTIFY | 
                    NIMBLE_PROPERTY::READ );

  pTxCharacteristicUart->setValue("VESC Uart TX");
  pTxCharacteristicUart->setCallbacks(new BleUartCallbacks());
   
/*
  NimBLE2904* pTxUartDescriptor = (NimBLE2904*)pTxCharacteristicUart->createDescriptor("2904"); 
  pTxUartDescriptor->setFormat(NimBLE2904::FORMAT_UTF8);
  pTxUartDescriptor->setCallbacks(&dscCallbacks);
*/

  NimBLECharacteristic * pRxCharacteristicUart = pServiceUart->createCharacteristic(
		                  VESC_CHARACTERISTIC_UUID_RX,
											NIMBLE_PROPERTY::WRITE | 
                      NIMBLE_PROPERTY::READ );

  pRxCharacteristicUart->setCallbacks(new BleUartCallbacks());

  // Create the BLE Blynk Service
  NimBLEService *pServiceBlynk = pServer->createService(BLYNK_SERVICE_UUID);

  // Create a BLE Characteristic for Blynk
  pTxCharacteristicBlynk = pServiceBlynk->createCharacteristic(
                      BLYNK_CHARACTERISTIC_UUID_TX,
                      NIMBLE_PROPERTY::NOTIFY);

  pTxCharacteristicBlynk->setValue("Blynk TX");
  pTxCharacteristicBlynk->setCallbacks(new BleBlynkCallbacks());
   
/*
  NimBLE2904* pTxBlynkDescriptor = (NimBLE2904*)pTxCharacteristicBlynk->createDescriptor("2904"); 
  pTxBlynkDescriptor->setFormat(NimBLE2904::FORMAT_UTF8);
  pTxBlynkDescriptor->setCallbacks(&dscCallbacks);
*/

  NimBLECharacteristic *pRxCharacteristicBlynk = pServiceBlynk->createCharacteristic(
                                        BLYNK_CHARACTERISTIC_UUID_RX,
                                        NIMBLE_PROPERTY::WRITE);

  pRxCharacteristicBlynk->setCallbacks(new BleBlynkCallbacks());

  // Start the UARTservice
  pServiceUart->start();
  // Start the service
  pServiceBlynk->start();

  // Start advertising
  NimBLEAdvertising* pAdvertising = NimBLEDevice::getAdvertising();
  pAdvertising->addServiceUUID(pServiceUart->getUUID());
  pAdvertising->addServiceUUID(pServiceBlynk->getUUID());
  pAdvertising->start();
#if DEBUG > 0
  Serial.println("Waiting for a BLE client connection...");
#endif

  Blynk.setDeviceName("Blynk");
  Blynk.begin(auth);
  initialized = true;
}

void BleServer::loop() {
  if(millis() - lastBlink > 2000) {
    blink = !blink;
    Blynk.virtualWrite(V0, blink);
    lastBlink = millis();
    Serial.println("Blink: " + String(blink));
  }
  Blynk.run();
  loopUart();
}

void BleServer::onConnect(NimBLEServer* pServer, ble_gap_conn_desc* desc) {
  //Uart stuff
#if DEBUG > 0
  Serial.println("BLE device connected");
  Serial.print("Client address: ");
  Serial.println(NimBLEAddress(desc->peer_ota_addr).toString().c_str());
  Serial.println("Multi-connect support: start advertising");
#endif
  deviceConnected = true;
  //Blynk stuff
  BLYNK_LOG1(BLYNK_F("BLE connect"));
  connect();
  Blynk.startSession();  
  NimBLEDevice::startAdvertising();
}

void BleServer::onDisconnect(NimBLEServer* pServer) {
  //Uart stuff
#if DEBUG > 0
     Serial.println("BLE device disconnected");
    Serial.println("Client disconnected - start advertising");
#endif
  deviceConnected = false;
  //Blynk stuff
  BLYNK_LOG1(BLYNK_F("BLE disconnect"));
  Blynk.disconnect();
  disconnect(); 
  NimBLEDevice::startAdvertising();
}

void BleServer::setDeviceName(const char* name) {}

// IP redirect not available
void BleServer::begin(char BLYNK_UNUSED *h, uint16_t BLYNK_UNUSED p) {}

void BleServer::begin() {}

bool BleServer::connect() {
  mBuffRX.clear();
  return mConn = true;
}

void BleServer::disconnect() {
  mConn = false;
}

bool BleServer::connected() {
  return mConn;
}

size_t BleServer::read(void* buf, size_t len) {
  millis_time_t start = BlynkMillis();
  while (BlynkMillis() - start < BLYNK_TIMEOUT_MS) {
    if (available() < len) {
      delay(1);
    } else {
      break;
    }
  }
  size_t res = mBuffRX.get((uint8_t*)buf, len);
  return res;
}

size_t BleServer::write(const void* buf, size_t len) {
  pTxCharacteristicBlynk->setValue((uint8_t*)buf, len);
  pTxCharacteristicBlynk->notify();
  return len;
}

size_t BleServer::available() {
  size_t rxSize = mBuffRX.size();
  return rxSize;
}


void BleServer::loopUart() {
  if(vescSerial->available()) {
    int oneByte;
#if DEBUG > 2
   Serial.print("\nBLE from VESC: ");
#endif
   while(vescSerial->available()) {
      oneByte = vescSerial->read();
      bufferString.push_back(oneByte);
#if DEBUG > 2
      Serial.print(oneByte, HEX);
#endif
    }

    if (deviceConnected) {
//      while(bufferString.length() > 600) {
        pTxCharacteristicUart->setValue(bufferString.substr(0, 600));
        pTxCharacteristicUart->notify();
//        delay(10);
//        bufferString = bufferString.substr(600);
//      }
      bufferString.clear();
		  delay(10); // bluetooth stack will go into congestion, if too many packets are sent
	  }
  }

  // disconnecting
  if (!deviceConnected && oldDeviceConnected) {
    delay(500); // give the bluetooth stack the chance to get things ready
    pServer->startAdvertising(); // restart advertising
#if DEBUG > 0
    Serial.println("start advertising");
#endif
    oldDeviceConnected = deviceConnected;
  }
  // connecting
  if (deviceConnected && !oldDeviceConnected) {
		// do stuff here on connecting
    oldDeviceConnected = deviceConnected;
  }
}